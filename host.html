<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quizmas Host</title>
  <link rel="stylesheet" href="./app.css" />
<style>.hidden{display:none !important;}</style>
</head>
<body>
  <div class="wrap">
    <h1>Host Console</h1>

    <div class="card">
      <div class="row">
        <div class="col">
          <label>Room code</label><br/>
          <input id="room" placeholder="e.g. quizmas" />
        </div>
        <div class="col">
          <button id="open">Open / Create Room</button>
          <button id="reset">Reset Buzz</button>
        </div>
      </div>
      <p class="small" id="status"></p>
    </div>

    <div class="card" id="live" style="display:none;">
      <div id="sectionBuzz">
        <p class="small">First buzz:</p>
        <div class="big" id="winner">—</div>
        <p class="small" id="lockInfo"></p>
      </div>

      <details id="scoresDetails" open>
        <summary><h2 style="display:inline">Scores</h2></summary>
        <div style="margin-top:10px;">
      <div id="scoreboard"></div>
      <p class="small">Teams appear here automatically when they join.</p>
        </div>
      </details>

      
      <hr/>
      <details id="liveDetails" open>
        <summary><h2 style="display:inline">Live Question</h2></summary>
        <div style="margin-top:10px;">
          <div class="card" style="background:#0f1627;">
        <div class="small" id="liveMeta">—</div>
        <div class="big" id="livePrompt">—</div>
        <div id="liveOptions" class="small" style="margin-top:8px;"></div>
        <div id="liveAnswer" class="small" style="margin-top:10px; display:none;"></div>
          <div id="awardTarget" class="small" style="margin-top:8px;"></div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div class="col">
          <label>Round</label><br/>
          <select id="roundSelect"></select>
        </div>
        <div class="col" style="display:flex; gap:8px; justify-content:flex-end; align-items:flex-end;">
          <button id="prevQ">Prev</button>
          <button id="nextQ">Next</button>
          <button id="revealQ">Reveal</button>
          <button id="hideQ">Hide</button>
          <button id="awardQPlus1">+1 Correct</button>
          <button id="awardQMinus1">-1 Wrong</button>
          <button id="awardQPlus2">+2</button>
        </div>
      </div>

        
</div>

      <details id="editorDetails">
        <summary><span class="small">Question editor (add/remove)</span></summary>
        <div class="card" style="margin-top:10px;">
          <div class="row">
            <div class="col">
              <label>Edit round</label><br/>
              <select id="editRoundSelect"></select>
              <div id="editorStatus" class="small" style="margin-top:6px; opacity:.85;"></div>
            </div>
            <div class="col" style="display:flex; gap:8px; justify-content:flex-end; align-items:flex-end;">
              <button id="addQA">Add Q&A</button>
              <button id="addMCQ">Add MCQ</button>
              <button id="saveBank">Save</button>
            </div>
          </div>
          <div id="editorList" style="margin-top:12px;"></div>
          <p class="small" style="opacity:.85; margin-top:10px;">
            Tip: edits are saved into this room (so you can tweak questions during the game).
          </p>
        </div>
      </details>

      </details>

            <details id="charadesDetails">
        <summary><h2 style="display:inline">Charades (Sherards)</h2></summary>
        <div style="margin-top:10px;">
<div class="row">
        <div class="col">
          <label>Acting team</label><br/>
          <select id="actorTeam"></select>
        </div>
        <div class="col">
          <label>Seconds</label><br/>
          <input id="charadesSeconds" type="number" value="60" min="10" />
        </div>
      </div>

      <div class="row">
        <button id="startCharadesBtn">Start</button>
        <button id="stopCharadesBtn">Stop</button>
        <button id="revealCharadesBtn">Reveal</button>
      </div>

      <p class="small" id="charadesInfo"></p>
      <div class="big" id="charadesTimer" style="display:none;">60</div>
      <p class="small" id="charadesReveal" style="display:none;"></p>

      <hr/>

      <h3>Award points (Charades)</h3>
      <div class="row">
        <div class="col">
          <label>Award to team</label><br/>
          <select id="awardTeam"></select>
        </div>
        <div class="col" style="display:flex; gap:8px; justify-content:flex-end;">
          <button id="awardMinus1">-1</button>
          <button id="awardPlus1">+1</button>
          <button id="awardPlus2">+2</button>
        </div>
      </div>
      <p class="small">Tip: set this to the guessing team that got it right, or just the acting team if you prefer.</p>
        </div>
      </details>
    </div>
  </div>

  <script type="module">
    import {
      ensureRoom,
      listenRoom,
      resetBuzz,
      changeScore,
      startCharades,
      stopCharades,
      revealCharades,
      setLiveQuestion,
      setReveal,
      ensureQuestionBank,
      saveQuestionBank
    } from "./common.js";
    import { QUIZ } from "./questions.js";

    const $ = (id) => document.getElementById(id);

    let roomId = null;
    let unsub = null;

    // latest snapshot state (fixes Stop/Reveal UI issues)
    let latestData = null;

    let selectedRoundId = "quickfire";
    let questionIndex = 0;

    function getBank() {
      return latestData?.questionBank || QUIZ;
    }
    function getRounds() {
      return (getBank()?.rounds || []);
    }

    function getRound(id) {
      return getRounds().find(r => r.id === id);
    }

    function renderRoundSelect() {
      const sel = $("roundSelect");
      sel.innerHTML = getRounds().map(r => `<option value="${r.id}">${r.name}</option>`).join("");
      sel.value = selectedRoundId;
    }

    async function pushLiveQuestion() {
      const round = getRound(selectedRoundId);
      if (!round) return;

      const qObj = round.questions[questionIndex % round.questions.length];
      const live = {
        roundId: round.id,
        roundType: round.type,
        index: questionIndex,
        prompt: qObj.q
      }

    // ---------- Question editor (host only) ----------
    let editRoundId = null;

    function setEditorStatus(msg) {
      const el = document.getElementById("editorStatus");
      if (el) el.textContent = msg || "";
    }

    function bankClone() {
      return JSON.parse(JSON.stringify(getBank() || { rounds: [] }));
    }

    async function setBank(bank) {
      if (!roomId) return;
      await saveQuestionBank(roomId, bank);
    }

    function renderEditorRoundSelect() {
      const sel = document.getElementById("editRoundSelect");
      if (!sel) return;

      const rounds = getRounds();
      sel.innerHTML = rounds.map(r => `<option value="${r.id}">${r.name} (${r.type})</option>`).join("");
      if (!rounds.length) {
        setEditorStatus("No rounds found yet. Try a new room code.");
        return;
      }
      if (!editRoundId) editRoundId = rounds[0].id;
      if (!rounds.some(r => r.id === editRoundId)) editRoundId = rounds[0].id;
      sel.value = editRoundId;

      setEditorStatus(`Rounds loaded: ${rounds.length} (${latestData?.questionBank ? "Firestore" : "Default"})`);
    }

    function renderEditorList() {
      const list = document.getElementById("editorList");
      if (!list) return;
      list.innerHTML = "";

      const round = getRounds().find(r => r.id === editRoundId);
      if (!round) {
        list.innerHTML = "<p class='small'>No round selected.</p>";
        return;
      }

      const qs = Array.isArray(round.questions) ? round.questions : [];
      if (!qs.length) list.innerHTML = "<p class='small'>No questions in this round yet.</p>";

      qs.forEach((q, idx) => {
        const wrap = document.createElement("div");
        wrap.className = "card";
        wrap.style.marginBottom = "10px";

        const head = document.createElement("div");
        head.className = "row";
        head.innerHTML = `
          <div class="col"><strong>Q${idx + 1}</strong> <span class="small">(${round.type})</span></div>
          <div class="col" style="display:flex; justify-content:flex-end;">
            <button data-del="${idx}">Delete</button>
          </div>
        `;
        wrap.appendChild(head);

        const qBox = document.createElement("textarea");
        qBox.style.width = "100%";
        qBox.style.minHeight = "60px";
        qBox.value = q.q || "";
        qBox.oninput = () => { q.q = qBox.value; };
        wrap.appendChild(qBox);

        if (round.type === "qa") {
          const aBox = document.createElement("textarea");
          aBox.style.width = "100%";
          aBox.style.minHeight = "48px";
          aBox.style.marginTop = "8px";
          aBox.placeholder = "Answer";
          aBox.value = q.a || "";
          aBox.oninput = () => { q.a = aBox.value; };
          wrap.appendChild(aBox);
        }

        if (round.type === "mcq") {
          q.options = Array.isArray(q.options) ? q.options : ["", "", "", ""];
          const optWrap = document.createElement("div");
          optWrap.style.marginTop = "8px";

          q.options.forEach((opt, i) => {
            const row = document.createElement("div");
            row.className = "row";
            row.style.alignItems = "center";
            row.innerHTML = `
              <div class="col" style="max-width:40px;"><strong>${String.fromCharCode(65+i)}.</strong></div>
              <div class="col"><input style="width:100%;" /></div>
              <div class="col" style="max-width:180px; text-align:right;">
                <label class="small"><input type="radio" name="correct_${idx}" value="${i}"> correct</label>
              </div>
            `;
            optWrap.appendChild(row);

            const inp = row.querySelector("input:not([type=radio])");
            inp.value = opt || "";
            inp.oninput = () => { q.options[i] = inp.value; };

            const radio = row.querySelector("input[type='radio']");
            radio.checked = Number(q.correctIndex ?? 0) === i;
            radio.onchange = () => { q.correctIndex = i; };
          });

          wrap.appendChild(optWrap);
        }

        list.appendChild(wrap);
      });

      list.querySelectorAll("button[data-del]").forEach(btn => {
        btn.onclick = async () => {
          const delIdx = Number(btn.getAttribute("data-del"));
          const bank = bankClone();
          const r = bank.rounds.find(r => r.id === editRoundId);
          if (!r || !Array.isArray(r.questions)) return;
          r.questions.splice(delIdx, 1);
          await setBank(bank);
        };
      });
    }

    function wireEditor() {
      const sel = document.getElementById("editRoundSelect");
      if (sel) sel.onchange = () => { editRoundId = sel.value; renderEditorList(); };

      const addQA = document.getElementById("addQA");
      if (addQA) addQA.onclick = async () => {
        const bank = bankClone();
        const r = bank.rounds.find(r => r.id === editRoundId);
        if (!r) return;
        if (r.type !== "qa") return alert("Select a Q&A round first.");
        r.questions = Array.isArray(r.questions) ? r.questions : [];
        r.questions.push({ q: "New question…", a: "Answer…" });
        await setBank(bank);
      };

      const addMCQ = document.getElementById("addMCQ");
      if (addMCQ) addMCQ.onclick = async () => {
        const bank = bankClone();
        const r = bank.rounds.find(r => r.id === editRoundId);
        if (!r) return;
        if (r.type !== "mcq") return alert("Select an MCQ round first.");
        r.questions = Array.isArray(r.questions) ? r.questions : [];
        r.questions.push({ q: "New MCQ…", options: ["A", "B", "C", "D"], correctIndex: 0 });
        await setBank(bank);
      };

      const saveBtn = document.getElementById("saveBank");
      if (saveBtn) saveBtn.onclick = async () => {
        await setBank(bankClone());
        alert("Saved.");
      };
    }
    wireEditor();

    function safeRenderEditor() {
      try { renderEditorRoundSelect(); renderEditorList(); } catch (e) { console.warn(e); }
    }


    // ---------- Question editor (host only) ----------
    let editRoundId = null;

    function renderEditorRoundSelect() {
      const sel = $("editRoundSelect");
      const rounds = getRounds();
      sel.innerHTML = rounds.map(r => `<option value="${r.id}">${r.name} (${r.type})</option>`).join("");
      if (!editRoundId) editRoundId = rounds[0]?.id || null;
      if (editRoundId && rounds.some(r => r.id === editRoundId)) sel.value = editRoundId;
      else if (rounds[0]) { editRoundId = rounds[0].id; sel.value = editRoundId; }
    }

    function bankClone() {
      return JSON.parse(JSON.stringify(getBank() || { rounds: [] }));
    }

    async function setBank(bank) {
      if (!roomId) return;
      await saveQuestionBank(roomId, bank);
    }

    function renderEditorList() {
      const list = $("editorList");
      list.innerHTML = "";

      const rounds = getRounds();
      const round = rounds.find(r => r.id === editRoundId);
      if (!round) {
        list.innerHTML = "<p class='small'>No round selected.</p>";
        return;
      }

      const qs = Array.isArray(round.questions) ? round.questions : [];
      if (!qs.length) list.innerHTML = "<p class='small'>No questions in this round yet.</p>";

      qs.forEach((q, idx) => {
        const wrap = document.createElement("div");
        wrap.className = "card";
        wrap.style.marginBottom = "10px";

        const head = document.createElement("div");
        head.className = "row";
        head.innerHTML = `
          <div class="col"><strong>Q${idx + 1}</strong> <span class="small">(${round.type})</span></div>
          <div class="col" style="display:flex; justify-content:flex-end;">
            <button data-del="${idx}">Delete</button>
          </div>
        `;
        wrap.appendChild(head);

        const qBox = document.createElement("textarea");
        qBox.style.width = "100%";
        qBox.style.minHeight = "60px";
        qBox.value = q.q || "";
        qBox.oninput = () => { q.q = qBox.value; };
        wrap.appendChild(qBox);

        if (round.type === "qa") {
          const aBox = document.createElement("textarea");
          aBox.style.width = "100%";
          aBox.style.minHeight = "48px";
          aBox.style.marginTop = "8px";
          aBox.placeholder = "Answer";
          aBox.value = q.a || "";
          aBox.oninput = () => { q.a = aBox.value; };
          wrap.appendChild(aBox);
        }

        if (round.type === "mcq") {
          q.options = Array.isArray(q.options) ? q.options : ["", "", "", ""];
          const optWrap = document.createElement("div");
          optWrap.style.marginTop = "8px";

          q.options.forEach((opt, i) => {
            const row = document.createElement("div");
            row.className = "row";
            row.style.alignItems = "center";
            row.innerHTML = `
              <div class="col" style="max-width:40px;"><strong>${String.fromCharCode(65+i)}.</strong></div>
              <div class="col"><input id="opt_${idx}_${i}" style="width:100%;" /></div>
              <div class="col" style="max-width:180px; text-align:right;">
                <label class="small"><input type="radio" name="correct_${idx}" value="${i}"> correct</label>
              </div>
            `;
            optWrap.appendChild(row);

            const inp = row.querySelector("input[id^='opt_']");
            inp.value = opt || "";
            inp.oninput = () => { q.options[i] = inp.value; };

            const radio = row.querySelector("input[type='radio']");
            radio.checked = Number(q.correctIndex ?? 0) === i;
            radio.onchange = () => { q.correctIndex = i; };
          });

          wrap.appendChild(optWrap);
        }

        list.appendChild(wrap);
      });

      list.querySelectorAll("button[data-del]").forEach(btn => {
        btn.onclick = async () => {
          const delIdx = Number(btn.getAttribute("data-del"));
          const bank = bankClone();
          const r = bank.rounds.find(r => r.id === editRoundId);
          if (!r || !Array.isArray(r.questions)) return;
          r.questions.splice(delIdx, 1);
          await setBank(bank);
        };
      });
    }

    $("editRoundSelect").onchange = () => {
      editRoundId = $("editRoundSelect").value;
      renderEditorList();
    };

    $("addQA").onclick = async () => {
      const bank = bankClone();
      const r = bank.rounds.find(r => r.id === editRoundId);
      if (!r) return;
      if (r.type !== "qa") return alert("Select a Q&A round first.");
      r.questions = Array.isArray(r.questions) ? r.questions : [];
      r.questions.push({ q: "New question…", a: "Answer…" });
      await setBank(bank);
    };

    $("addMCQ").onclick = async () => {
      const bank = bankClone();
      const r = bank.rounds.find(r => r.id === editRoundId);
      if (!r) return;
      if (r.type !== "mcq") return alert("Select an MCQ round first.");
      r.questions = Array.isArray(r.questions) ? r.questions : [];
      r.questions.push({ q: "New MCQ…", options: ["A", "B", "C", "D"], correctIndex: 0 });
      await setBank(bank);
    };

    $("saveBank").onclick = async () => {
      const bank = bankClone();
      await setBank(bank);
      alert("Saved.");
    };
;

      if (round.type === "qa") {
        live.answer = qObj.a;
      } else if (round.type === "mcq") {
        live.options = qObj.options;
        live.correctIndex = qObj.correctIndex;
        live.answer = qObj.options[qObj.correctIndex];
      }

      await setLiveQuestion(roomId, live);
    }


    // You can replace these later with your real charades list
    const CHARADES_NAMES = [
  "Taylor Swift",
  "Beyoncé",
  "Ed Sheeran",
  "Elton John",
  "James Bond",
  "Indiana Jones",
  "Darth Vader",
  "Mr Bean",
  "David Brent",
  "Homer Simpson",
  "Del Boy",
  "Joey Tribbiani",
  "The Grinch",
  "Santa Claus",
  "Kevin McCallister",
  "Rocky Balboa",
  "Forrest Gump",
  "Henry VIII",
  "Napoleon Bonaparte",
  "Winston Churchill",
  "Cleopatra",
  "Abraham Lincoln",
  "The Joker",
  "Voldemort",
  "Thanos",
  "Austin Powers",
  "Borat",
  "Shrek",
  "Mario",
  "Scooby-Doo",
  "Wallace",
  "The Michelin Man",
  "Buddy the Elf",
  "Ebenezer Scrooge",
  "Rudolph the Red-Nosed Reindeer",
  "The Snowman",
  "A Turkey"
];

    let charadesIndex = 0;

    function renderScores(teams = [], scores = {}) {
      const box = $("scoreboard");
      box.innerHTML = "";

      if (!teams.length) {
        box.innerHTML = "<p class='small'>No teams yet.</p>";
        $("actorTeam").innerHTML = "";
        $("awardTeam").innerHTML = "";
        return;
      }

      // ✅ Preserve current selections (prevents dropdown resetting to first team)
      const prevActor = $("actorTeam").value;
      const prevAward = $("awardTeam").value;

      // Rebuild dropdowns
      $("actorTeam").innerHTML = teams.map(t => `<option value="${t}">${t}</option>`).join("");
      $("awardTeam").innerHTML = teams.map(t => `<option value="${t}">${t}</option>`).join("");

      // ✅ Restore previous selection if still valid
      if (prevActor && teams.includes(prevActor)) $("actorTeam").value = prevActor;
      if (prevAward && teams.includes(prevAward)) $("awardTeam").value = prevAward;

      teams.forEach((team) => {
        const score = Number(scores[team] ?? 0);

        const row = document.createElement("div");
        row.className = "row";
        row.style.alignItems = "center";

        row.innerHTML = `
          <div class="col"><strong>${team}</strong> <span class="small">(${score})</span></div>
          <div class="col" style="display:flex; gap:8px; justify-content:flex-end;">
            <button data-d="-2">-2</button>
            <button data-d="-1">-1</button>
            <button data-d="1">+1</button>
            <button data-d="2">+2</button>
          </div>
        `;

        row.querySelectorAll("button").forEach((btn) => {
          btn.onclick = async () => {
            const delta = Number(btn.getAttribute("data-d"));
            await changeScore(roomId, team, delta);
          };
        });

        box.appendChild(row);
      });
    }

    
    function updateVisibility(data) {
      const round = data?.game?.round ?? null;
      const hasLive = !!data?.live;
      const showCharades = round === "charades";
      const showLive = !showCharades && hasLive;

      const liveDetails = document.getElementById("liveDetails");
      const charadesDetails = document.getElementById("charadesDetails");
      const scoresDetails = document.getElementById("scoresDetails");
      const buzzSection = document.getElementById("sectionBuzz");
const roundActive = showCharades || showLive;

      if (liveDetails) liveDetails.open = showLive;
      if (charadesDetails) charadesDetails.open = showCharades;
      if (scoresDetails) scoresDetails.open = !roundActive;

      if (buzzSection) buzzSection.classList.toggle("hidden", roundActive);
    }

function renderCharades(data) {
      const round = data?.game?.round ?? null;
      const ch = data?.charades ?? null;

      if (round !== "charades" || !ch) {
        $("charadesInfo").textContent = "Not running.";
        $("charadesTimer").style.display = "none";
        $("charadesReveal").style.display = "none";
        return;
      }

      $("charadesInfo").textContent = ch.actorTeam
        ? `Acting team: ${ch.actorTeam}`
        : "Pick an acting team and press Start.";

      // Timer (always based on latestData — no stale snapshots)
      $("charadesTimer").style.display = "block";
      if (ch.running && typeof ch.endsAt === "number") {
        const remaining = Math.max(0, Math.ceil((ch.endsAt - Date.now()) / 1000));
        $("charadesTimer").textContent = String(remaining);
      } else {
        $("charadesTimer").textContent = "0";
      }

      // Reveal
      if (ch.revealed) {
        $("charadesReveal").style.display = "block";
        $("charadesReveal").textContent = `Answer: ${ch.person ?? "—"}`;
      } else {
        $("charadesReveal").style.display = "none";
      }
    }

    // Timer tick (updates only display — Firestore is source of truth)
    setInterval(() => {
      if (latestData) renderCharades(latestData);
    }, 200);

    $("open").onclick = async () => {
      roomId = $("room").value.trim();
      if (!roomId) {
        $("status").textContent = "Enter a room code.";
        return;
      }

      $("status").textContent = "Opening room…";
      await ensureRoom(roomId);
      await ensureQuestionBank(roomId, QUIZ);
      await ensureQuestionBank(roomId, QUIZ);

      $("live").style.display = "block";
      renderRoundSelect();
      $("status").textContent = `Room ready: ${roomId}`;

      if (unsub) unsub();
      unsub = listenRoom(roomId, (data) => {
        latestData = data;
        safeRenderEditor();
        // Always render core UI first (so a broken editor can't break gameplay)
        renderRoundSelect();
        updateVisibility(data);

        // Render question editor (guarded)
        try {
          if (document.getElementById("editRoundSelect")) {
            renderEditorRoundSelect();
            renderEditorList();
          }
        } catch (e) {
          console.warn("Editor render failed", e);
        }

        const lockedBy = data?.buzz?.lockedBy ?? null;
        $("winner").textContent = lockedBy ? lockedBy : "—";
        const awardEl = document.getElementById("awardTarget");
        if (awardEl) {
          awardEl.textContent = lockedBy ? `Award points to: ${lockedBy}` : "Award points to: (no buzz yet)";
        }
        $("lockInfo").textContent = lockedBy
          ? "Buzz is locked. Reset to continue."
          : "Buzz is open.";

        renderScores(data?.teams || [], data?.scores || {});
        renderCharades(data);


        const liveQ = data?.live || null;
        const reveal = !!data?.reveal;

        if (!liveQ) {
          $("liveMeta").textContent = "No live question";
          $("livePrompt").textContent = "—";
          $("liveOptions").textContent = "";
          $("liveAnswer").style.display = "none";
        } else {
          $("liveMeta").textContent = `${liveQ.roundId.toUpperCase()} • Q${(liveQ.index ?? 0) + 1}`;
          $("livePrompt").textContent = liveQ.prompt || "—";

          if (liveQ.roundType === "mcq" && Array.isArray(liveQ.options)) {
            $("liveOptions").innerHTML = liveQ.options
              .map((o,i)=>`<div><strong>${String.fromCharCode(65+i)}.</strong> ${o}</div>`)
              .join("");
          } else {
            $("liveOptions").textContent = "";
          }

          if (reveal) {
            $("liveAnswer").style.display = "block";
            $("liveAnswer").textContent = `Answer: ${liveQ.answer ?? "—"}`;
          } else {
            $("liveAnswer").style.display = "none";
          }
        }


        // Helpful default: when charades is active, set award dropdown to acting team
        if (data?.game?.round === "charades" && data?.charades?.actorTeam) {
          const actor = data.charades.actorTeam;
          if ([...$("awardTeam").options].some(o => o.value === actor)) {
            $("awardTeam").value = actor;
          }
        }
      });
    };

    $("reset").onclick = async () => {
      if (!roomId) return;
      await resetBuzz(roomId);
    };

    $("startCharadesBtn").onclick = async () => {
      if (!roomId) return;

      const actorTeam = $("actorTeam").value;
      const seconds = Number($("charadesSeconds").value || 60);
      if (!actorTeam) {
        alert("No teams yet — ask teams to join first.");
        return;
      }

      const person = CHARADES_NAMES[charadesIndex % CHARADES_NAMES.length];
      charadesIndex++;

      await startCharades(roomId, actorTeam, person, seconds);

      // default awarding to the acting team (you can change it)
      $("awardTeam").value = actorTeam;
    };

    $("stopCharadesBtn").onclick = async () => {
      if (!roomId) return;
      await stopCharades(roomId);
    };

    $("revealCharadesBtn").onclick = async () => {
      if (!roomId) return;
      await revealCharades(roomId);
    };

    
    $("roundSelect").onchange = async () => {
      selectedRoundId = $("roundSelect").value;
      questionIndex = 0;
      await pushLiveQuestion();
    };

    $("nextQ").onclick = async () => {
      questionIndex++;
      await pushLiveQuestion();
    };

    $("prevQ").onclick = async () => {
      questionIndex = Math.max(0, questionIndex - 1);
      await pushLiveQuestion();
    };

    $("revealQ").onclick = async () => {
      if (!roomId) return;
      await setReveal(roomId, true);
    };

    $("hideQ").onclick = async () => {
      if (!roomId) return;
      await setReveal(roomId, false);
    };

    function getBuzzWinner() {
      return latestData?.buzz?.lockedBy || null;
    }

    async function awardToWinner(delta) {
      if (!roomId) return;
      const winner = getBuzzWinner();
      if (!winner) {
        alert("No team has buzzed in yet.");
        return;
      }
      await changeScore(roomId, winner, delta);
    }

    $("awardQPlus1").onclick = async () => awardToWinner(1);
    $("awardQMinus1").onclick = async () => awardToWinner(-1);
    $("awardQPlus2").onclick = async () => awardToWinner(2);


    // Award points buttons
    $("awardMinus1").onclick = async () => {
      if (!roomId) return;
      const team = $("awardTeam").value;
      if (!team) return;
      await changeScore(roomId, team, -1);
    };

    $("awardPlus1").onclick = async () => {
      if (!roomId) return;
      const team = $("awardTeam").value;
      if (!team) return;
      await changeScore(roomId, team, 1);
    };

    $("awardPlus2").onclick = async () => {
      if (!roomId) return;
      const team = $("awardTeam").value;
      if (!team) return;
      await changeScore(roomId, team, 2);
    };
  
    // Re-render editor when opened
    try {
      const ed = document.getElementById("editorDetails");
      if (ed) ed.addEventListener("toggle", () => { if (ed.open) safeRenderEditor(); });
    } catch (e) {}
</script>
</body>
</html>
